<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Smart City Digital Twin - Map Visualization</title>
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <style>
        body {
            margin: 0;
            padding: 0;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }
        
        #map {
            width: 100vw;
            height: 100vh;
        }
        
        .legend {
            position: absolute;
            bottom: 30px;
            right: 10px;
            background: white;
            padding: 15px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.2);
            z-index: 1000;
            font-size: 12px;
        }
        
        .legend h4 {
            margin: 0 0 10px 0;
            font-size: 14px;
        }
        
        .legend-item {
            margin: 5px 0;
            display: flex;
            align-items: center;
        }
        
        .legend-color {
            width: 30px;
            height: 4px;
            margin-right: 8px;
            border-radius: 2px;
        }
        
        .layer-controls {
            position: absolute;
            top: 10px;
            right: 10px;
            background: white;
            padding: 15px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.2);
            z-index: 1000;
        }
        
        .layer-controls h4 {
            margin: 0 0 10px 0;
            font-size: 14px;
        }
        
        .layer-controls label {
            display: block;
            margin: 5px 0;
            cursor: pointer;
        }
        
        .sensor-icon {
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .leaflet-popup-content {
            margin: 10px;
            font-size: 13px;
        }
        
        .leaflet-popup-content h3 {
            margin: 0 0 8px 0;
            font-size: 15px;
        }
    </style>
</head>
<body>
    <div id="map"></div>
    
    <div class="legend">
        <h4>Traffic Congestion</h4>
        <div class="legend-item">
            <div class="legend-color" style="background: #4CAF50; height: 3px;"></div>
            <span>Light</span>
        </div>
        <div class="legend-item">
            <div class="legend-color" style="background: #FFC107; height: 5px;"></div>
            <span>Moderate</span>
        </div>
        <div class="legend-item">
            <div class="legend-color" style="background: #F44336; height: 7px;"></div>
            <span>Heavy</span>
        </div>
    </div>
    
    <div class="layer-controls">
        <h4>Map Layers</h4>
        <label><input type="checkbox" id="toggle-districts" checked> Districts</label>
        <label><input type="checkbox" id="toggle-roads" checked> Roads</label>
        <label><input type="checkbox" id="toggle-sensors" checked> Sensors</label>
        <label><input type="checkbox" id="toggle-buildings" checked> Buildings</label>
        <label><input type="checkbox" id="toggle-weather" checked> Weather Stations</label>
    </div>
    
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <script src="geojson-generator.js"></script>
    <script>
        // Initialize the map
        const map = L.map('map').setView([40.7128, -74.0060], 14);
        
        // Add base map tiles
        L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
            attribution: '© OpenStreetMap contributors',
            maxZoom: 19
        }).addTo(map);
        
        // Layer groups for toggling
        const layers = {
            districts: L.layerGroup().addTo(map),
            roads: L.layerGroup().addTo(map),
            sensors: L.layerGroup().addTo(map),
            buildings: L.layerGroup().addTo(map),
            weather: L.layerGroup().addTo(map)
        };
        
        // Load and visualize the digital twin data
        fetch('city-digital-twin.json')
            .then(response => response.json())
            .then(digitalTwinState => {
                // Generate all GeoJSON layers
                const geoJsonLayers = generateAllGeoJSON(digitalTwinState);
                
                // 1. Add district boundaries
                L.geoJSON(geoJsonLayers.districts, {
                    style: {
                        color: '#2196F3',
                        weight: 2,
                        fillOpacity: 0.05,
                        fillColor: '#2196F3'
                    },
                    onEachFeature: (feature, layer) => {
                        const props = feature.properties;
                        layer.bindPopup(`
                            <h3>${props.name}</h3>
                            <p><strong>District ID:</strong> ${props.districtId}</p>
                            <p><strong>Center:</strong> ${props.centerLatitude.toFixed(4)}, ${props.centerLongitude.toFixed(4)}</p>
                        `);
                    }
                }).addTo(layers.districts);
                
                // 2. Add roads with congestion visualization
                L.geoJSON(geoJsonLayers.roads, {
                    style: (feature) => ({
                        color: feature.properties.strokeColor,
                        weight: feature.properties.strokeWidth,
                        opacity: 0.8
                    }),
                    onEachFeature: (feature, layer) => {
                        const props = feature.properties;
                        const incidentWarning = props.hasIncidents 
                            ? `<p style="color: red; font-weight: bold;">⚠️ ${props.incidentCount} Incident(s)</p>` 
                            : '';
                        
                        layer.bindPopup(`
                            <h3>${props.name}</h3>
                            <p><strong>Congestion:</strong> ${props.congestionLevel}</p>
                            <p><strong>Avg Speed:</strong> ${props.averageSpeed} km/h (limit: ${props.speedLimit} km/h)</p>
                            <p><strong>Vehicles:</strong> ${props.vehicleCount}</p>
                            <p><strong>Travel Time:</strong> ${props.travelTime} min</p>
                            <p><strong>Lanes:</strong> ${props.lanes} (${props.direction})</p>
                            ${incidentWarning}
                            <p style="font-size: 11px; color: #666;">Last updated: ${new Date(props.lastUpdated).toLocaleTimeString()}</p>
                        `);
                    }
                }).addTo(layers.roads);
                
                // 3. Add sensors as markers
                L.geoJSON(geoJsonLayers.sensors, {
                    pointToLayer: (feature, latlng) => {
                        const sensorType = feature.properties.type;
                        const icon = L.divIcon({
                            className: 'sensor-icon',
                            html: `<div style="background: ${getSensorColor(sensorType)}; width: 14px; height: 14px; border-radius: 50%; border: 2px solid white; box-shadow: 0 2px 4px rgba(0,0,0,0.3);"></div>`,
                            iconSize: [14, 14]
                        });
                        return L.marker(latlng, { icon: icon });
                    },
                    onEachFeature: (feature, layer) => {
                        const props = feature.properties;
                        let extraInfo = '';
                        
                        if (props.type === 'trafficCamera') {
                            extraInfo = `
                                <p><strong>Avg Speed:</strong> ${props.avgSpeed} km/h</p>
                                <p><strong>Vehicles:</strong> ${props.vehicleCount}</p>
                                <p><strong>Status:</strong> ${props.congestionStatus}</p>
                            `;
                        }
                        
                        layer.bindPopup(`
                            <h3>${props.type}</h3>
                            <p><strong>Sensor ID:</strong> ${props.sensorId}</p>
                            <p><strong>Value:</strong> ${props.value} ${props.unit}</p>
                            ${extraInfo}
                            <p><strong>District:</strong> ${props.districtName}</p>
                            <p><strong>Status:</strong> ${props.status}</p>
                            <p style="font-size: 11px; color: #666;">Last updated: ${new Date(props.lastUpdated).toLocaleTimeString()}</p>
                        `);
                    }
                }).addTo(layers.sensors);
                
                // 4. Add buildings
                L.geoJSON(geoJsonLayers.buildings, {
                    pointToLayer: (feature, latlng) => {
                        const occupancyRate = feature.properties.occupancyRate;
                        const color = occupancyRate > 0.8 ? '#F44336' : occupancyRate > 0.5 ? '#FFC107' : '#4CAF50';
                        
                        return L.circleMarker(latlng, {
                            radius: 10,
                            fillColor: color,
                            color: '#FFF',
                            weight: 2,
                            opacity: 1,
                            fillOpacity: 0.7
                        });
                    },
                    onEachFeature: (feature, layer) => {
                        const props = feature.properties;
                        layer.bindPopup(`
                            <h3>${props.name}</h3>
                            <p><strong>Type:</strong> ${props.type}</p>
                            <p><strong>Address:</strong> ${props.address}</p>
                            <p><strong>Floors:</strong> ${props.floors}</p>
                            <p><strong>Occupancy:</strong> ${props.currentOccupancy}/${props.totalCapacity} (${(props.occupancyRate * 100).toFixed(1)}%)</p>
                            <p><strong>Status:</strong> ${props.status}</p>
                            <p><strong>District:</strong> ${props.districtName}</p>
                        `);
                    }
                }).addTo(layers.buildings);
                
                // 5. Add weather stations
                L.geoJSON(geoJsonLayers.weatherStations, {
                    pointToLayer: (feature, latlng) => {
                        const icon = L.divIcon({
                            className: 'sensor-icon',
                            html: `<div style="background: #00BCD4; width: 18px; height: 18px; border-radius: 50%; border: 3px solid white; box-shadow: 0 2px 6px rgba(0,0,0,0.4);">
                                <span style="position: absolute; top: -2px; left: 4px; font-size: 10px;">☁</span>
                            </div>`,
                            iconSize: [18, 18]
                        });
                        return L.marker(latlng, { icon: icon });
                    },
                    onEachFeature: (feature, layer) => {
                        const props = feature.properties;
                        layer.bindPopup(`
                            <h3>${props.name}</h3>
                            <p><strong>Temperature:</strong> ${props.temperature}°C</p>
                            <p><strong>Humidity:</strong> ${props.humidity}%</p>
                            <p><strong>Wind:</strong> ${props.windSpeed} km/h (${props.windDirection}°)</p>
                            <p><strong>Pressure:</strong> ${props.pressure} hPa</p>
                            <p><strong>Precipitation:</strong> ${props.precipitation} mm</p>
                            <p><strong>Visibility:</strong> ${props.visibility} km</p>
                            <p><strong>UV Index:</strong> ${props.uvIndex}</p>
                            <p><strong>District:</strong> ${props.districtName}</p>
                            <p style="font-size: 11px; color: #666;">Last updated: ${new Date(props.lastUpdated).toLocaleTimeString()}</p>
                        `);
                    }
                }).addTo(layers.weather);
            })
            .catch(error => {
                console.error('Error loading digital twin data:', error);
                alert('Failed to load digital twin data. Make sure city-digital-twin.json is in the same directory.');
            });
        
        // Helper function to get sensor colors
        function getSensorColor(sensorType) {
            const colors = {
                'trafficCamera': '#2196F3',
                'pm25': '#9C27B0',
                'noise': '#FF9800',
                'vehicleCount': '#4CAF50',
                'parkingOccupancy': '#F44336',
                'temperature': '#E91E63',
                'humidity': '#03A9F4',
                'powerConsumption': '#FFEB3B',
                'occupancy': '#795548',
                'accessEvents': '#607D8B',
                'waterFlowRate': '#00BCD4',
                'waterPressure': '#009688',
                'crowdCount': '#673AB7'
            };
            return colors[sensorType] || '#9E9E9E';
        }
        
        // Layer toggle controls
        document.getElementById('toggle-districts').addEventListener('change', (e) => {
            e.target.checked ? map.addLayer(layers.districts) : map.removeLayer(layers.districts);
        });
        
        document.getElementById('toggle-roads').addEventListener('change', (e) => {
            e.target.checked ? map.addLayer(layers.roads) : map.removeLayer(layers.roads);
        });
        
        document.getElementById('toggle-sensors').addEventListener('change', (e) => {
            e.target.checked ? map.addLayer(layers.sensors) : map.removeLayer(layers.sensors);
        });
        
        document.getElementById('toggle-buildings').addEventListener('change', (e) => {
            e.target.checked ? map.addLayer(layers.buildings) : map.removeLayer(layers.buildings);
        });
        
        document.getElementById('toggle-weather').addEventListener('change', (e) => {
            e.target.checked ? map.addLayer(layers.weather) : map.removeLayer(layers.weather);
        });
    </script>
</body>
</html>
